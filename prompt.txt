Vreau sÄƒ GENERZI o paginÄƒ de start pentru o suitÄƒ de jocuri pentru copii, Ã®n HTML/CSS/JS pur (fÄƒrÄƒ plugin-uri, fÄƒrÄƒ framework-uri, fÄƒrÄƒ fonturi externe). Totul trebuie sÄƒ funcÈ›ioneze ca fiÈ™iere statice.

# Obiectiv
- O â€œpaginÄƒ de startâ€ care:
  1) aratÄƒ un **meniu cu jocuri** (carduri responsive),
  2) afiÈ™eazÄƒ **scoreboard** global: â­ Puncte, ğŸ¬ Bomboane,
  3) are un **toggle de avatar** (ğŸ‘¦/ğŸ‘§),
  4) oferÄƒ **RecompensÄƒ zilnicÄƒ** (gratuit) o datÄƒ pe zi,
  5) permite **conversie** Puncte â†’ Bomboane (ratÄƒ fixÄƒ 100p = 1ğŸ¬),
  6) Ã®ncarcÄƒ jocurile Ã®ntr-un **iframe** È™i comunicÄƒ bi-direcÈ›ional cu ele prin `postMessage`,
  7) **pÄƒstreazÄƒ progresul** Ã®n `localStorage`.

# ConstrÃ¢ngeri tehnice
- Doar HTML, CSS È™i JS nativ. FÄƒrÄƒ biblioteci externe.
- StructurÄƒ staticÄƒ de fiÈ™iere (fÄƒrÄƒ build, fÄƒrÄƒ Node).
- UI Ã®n **limba romÃ¢nÄƒ**.
- Design modern/dark, cu paleta: 
  - bg `#0f172a`, panel `#111827`, text `#f9fafb`, primary `#22c55e`, accent `#60a5fa`, muted `#9ca3af`.
- Sistem-font (system-ui) â€“ nu Ã®ncÄƒrca fonturi din web.
- Accesibilitate de bazÄƒ: `aria-live="polite"` pe scoreboard, `title` pe iframe, `role="region"` pe lista de jocuri, focus vizibil.
- **Aliniere butoane Ã®n carduri:** fiecare `.card` e coloanÄƒ flex, iar butonul â€œJoacÄƒâ€ stÄƒ **aliniat jos** (foloseÈ™te `.card > .btn { margin-top: auto; }`).
- FÄƒrÄƒ componentÄƒ de platÄƒ. Bonusurile vin doar din jocuri È™i din recompensa zilnicÄƒ.

# Structura proiectului (exact aÈ™a)
/
â”œâ”€ index.html
â”œâ”€ assets/
â”‚  â”œâ”€ css/
â”‚  â”‚  â”œâ”€ base.css
â”‚  â”‚  â””â”€ home.css
â”‚  â””â”€ js/
â”‚     â”œâ”€ config.js
â”‚     â”œâ”€ state.js
â”‚     â”œâ”€ ui.js
â”‚     â”œâ”€ daily.js
â”‚     â”œâ”€ bus.js
â”‚     â””â”€ main.js
â””â”€ games/
   â”œâ”€ ducks/index.html
   â”œâ”€ math/index.html
   â”œâ”€ balloons/index.html
   â””â”€ treasure/index.html

> Pentru focusul pe â€œpagina de startâ€, jocurile pot fi doar pagini demo foarte scurte care trimit/recepÈ›ioneazÄƒ mesaje conform protocolului de mai jos (doar pentru a testa integrarea).

# ConÈ›inut & comportament

## index.html
- Header cu brand â€œMini-Jocuri â€¢ Eduâ€.
- Scoreboard (douÄƒ â€œpill-uriâ€): â­ Puncte, ğŸ¬ Bomboane (cu micro-animaÈ›ie â€œbumpâ€ la update).
- Toggle avatar ğŸ‘¦/ğŸ‘§ (salvat Ã®n localStorage).
- Sub-bar: breadcrumb (Meniu / Nume joc), butoane:
  - â€œğŸ Recompensa zilnicÄƒâ€
  - â€œâ†”ï¸ ConvertÄƒ puncte â†’ bomboaneâ€
- Meniu jocuri (grid de carduri) cu 4 jocuri:
  - RÄƒÈ›uÈ™te pe nuferi ğŸ¦†
  - AdunÄƒri & ScÄƒderi ğŸ¬
  - Balonul potrivit ğŸˆ
  - VÃ¢nÄƒtoarea de comori ğŸ’
- Fiecare card are titlu, descriere scurtÄƒ È™i buton **JoacÄƒ** aliniat la bazÄƒ (vezi cerinÈ›a de aliniere).
- Iframe (ascuns iniÈ›ial) pentru a Ã®ncÄƒrca jocul selectat.
- Footer cu Â© È™i buton â€œâŸµ Meniuâ€ care revine din joc la lista de jocuri.
- ZonÄƒ de **toasts** pentru feedback simplu (JS nativ, fÄƒrÄƒ lib).

## CSS
- `base.css`: variabile CSS (paleta), layout (grid body: header, sub-header, main, footer), componente (bar, pill, card, btn, toast), animaÈ›ii (`bump`, `slideIn`).
- `home.css`: stiluri specifice paginii (breadcrumb, acÈ›iuni, stil iframe).
- Important: `.card { display:flex; flex-direction:column; }` + `.card > .btn { margin-top:auto; }` pentru alinierea butoanelor.

## JS

### config.js
- Export global `window.CONFIG`:
  - `CONVERSION.POINTS_PER_CANDY = 100`
  - `DAILY_REWARD.candies = 3`
  - `LIMITS = { POINTS_PER_MESSAGE: 100, CANDIES_PER_MESSAGE: 3, MESSAGES_PER_5S: 10 }`
  - `GAMES = { ducks:'RÄƒÈ›uÈ™te pe nuferi', math:'AdunÄƒri & ScÄƒderi', balloons:'Balonul potrivit', treasure:'VÃ¢nÄƒtoarea de comori' }`

### state.js
- Stocare Ã®n `localStorage` sub cheia `mje_state_v1`.
- Structura statului:
- API global `window.State`:
- `get()`, `getPublic()`, `setAvatar(a)`,
- `addPoints(n)`, `addCandies(n)`,
- `convertPointsToCandies(count)` (validÄƒri + scÄƒdere puncte),
- `convertAllPossible()` (opÈ›ional),
- `setLastDailyReward(iso)`, `unlockBadge(id)`.

### ui.js
- `window.UI` cu:
- `updateHeader(state)` (È™i animaÈ›ia bump),
- `showToast(text)`,
- `showBreadcrumb(gameName|null)`,
- `toggleViews('menu'|'game')`.

### daily.js
- `window.Daily` cu:
- `isAvailable(lastISO)`: disponibil o datÄƒ pe zi,
- `claim()`: +`CONFIG.DAILY_REWARD.candies`, seteazÄƒ `lastDailyReward` la `yyyy-mm-dd`.

### bus.js (protocol postMessage)
- AcceptÄƒ DOAR mesaje de la `window.location.origin` È™i de la iframe-ul curent.
- Anti-spam simplu: max `CONFIG.LIMITS.MESSAGES_PER_5S` per joc/5s.
- Tipuri mesaje joc â†’ paginÄƒ:
- `addPoints { value:number>0, reason?:string }`
- `addCandies { value:number>0, reason?:string }`
- `requestPlayerState`
- `gameOver { score?:number, canSafelyExit?:boolean }`
- `achievementUnlocked { id:string }` (opÈ›ional)
- Tipuri mesaje paginÄƒ â†’ joc:
- `playerState { points, candies, avatar, equipped, badges }`
- `avatarChanged { avatar, equipped }`
- La `addPoints`/`addCandies` aplicÄƒ capurile per mesaj din `CONFIG.LIMITS` È™i actualizeazÄƒ UI (toast + scoreboard).

### main.js (logica paginii)
- InitializeazÄƒ UI din `State`.
- LeagÄƒ butoanele din meniu (`[data-game]`) â†’ seteazÄƒ breadcrumb, ascunde meniu, aratÄƒ iframe, Ã®ncarcÄƒ `./games/<id>/index.html?avatar=<>&game=<id>`.
- Buton â€œâŸµ Meniuâ€ goleÈ™te `src` la iframe, revine la meniu.
- Toggle avatar schimbÄƒ `State.avatar` È™i trimite `avatarChanged` cÄƒtre jocul curent (dacÄƒ e deschis).
- â€œğŸ Recompensa zilnicÄƒâ€ â†’ dacÄƒ disponibil, +candies, toast, update UI.
- â€œâ†”ï¸ ConvertÄƒ puncte â†’ bomboaneâ€ â†’ prompt cu numÄƒr de bomboane dorit (max posibil), validÄƒri, conversie, toast, update UI.

## Jocuri (doar pentru test)
- Fiecare joc demo doar are 2â€“4 butoane care trimit mesaje:
- `addPoints`, `addCandies`, `requestPlayerState`, `gameOver`.
- Jocurile ascultÄƒ `playerState` È™i `avatarChanged`.

# CerinÈ›e de ieÈ™ire
- LivreazÄƒ **toate fiÈ™ierele** exact pe structura de mai sus, cu cod complet (HTML/CSS/JS) È™i comentarii scurte unde e util.
- Nu folosi biblioteci externe sau CDN-uri.
- AsigurÄƒ alinierea perfectÄƒ a butoanelor â€œJoacÄƒâ€ pe acelaÈ™i rÃ¢nd Ã®n grid, indiferent de lungimea descrierii cardurilor.
- UI sÄƒ fie responsive È™i lizibil pe mobil È™i desktop.

# Criterii de acceptare (MVP)
- Refresh nu pierde punctele/bomboanele/avatarul (persistÄƒ).
- â€œRecompensa zilnicÄƒâ€ se poate lua o singurÄƒ datÄƒ pe zi (se dezactiveazÄƒ dupÄƒ).
- Conversia funcÈ›ioneazÄƒ doar dacÄƒ existÄƒ cel puÈ›in 100p per 1ğŸ¬; mesaj de eroare cÃ¢nd nu sunt suficiente puncte.
- Jocul (iframe) poate obÈ›ine `playerState` È™i poate adÄƒuga puncte/bomboane.
- Mesajele necunoscute/origin diferit sunt ignorate; rate-limit activ.

GenereazÄƒ acum fiÈ™ierele.










<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RÄƒÈ›uÈ™te pe nuferi ğŸ¦†</title>
  <link rel="stylesheet" href="./ducks.css" />
</head>
<body>
  <header>
    <div class="bar">
      <div class="brand">RÄƒÈ›uÈ™te <span>Edu</span></div>
      <div class="scoreboard">
        <div class="pill" id="totalPoints">â­ Puncte: 0</div>
        <div class="pill" id="totalCandies">ğŸ¬ Bomboane: 0</div>
      </div>
    </div>
  </header>

  <main>
    <div id="screen" class="panel"></div>
  </main>

  <footer>
    <div class="bar">
      <span class="muted">Â© 2025 RÄƒÈ›uÈ™te Edu</span>
    </div>
  </footer>

  <script src="./ducks.js"></script>
</body>
</html>
// Stare localÄƒ (Ã®n iframe)
const App = {
  points: 0,
  candies: 0,
  addPoints(n=1){ this.points += n; UI.updateHeader(); syncToParent('addPoints', n); },
  addCandies(n=1){ this.candies += n; UI.updateHeader(); syncToParent('addCandies', n); }
};

function syncToParent(type, value){
  // trimite scorul cÄƒtre pagina pÄƒrinte (index.html cu iframe)
  if (window.parent && window.parent !== window) {
    window.parent.postMessage({ type, value }, '*');
  }
}

const UI = {
  screen: document.getElementById('screen'),
  updateHeader(){
    document.getElementById('totalPoints').textContent = `â­ Puncte: ${App.points}`;
    document.getElementById('totalCandies').textContent = `ğŸ¬ Bomboane: ${App.candies}`;
  },
  clear(){ this.screen.innerHTML = ''; }
};

function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
function shuffle(arr){ return arr.sort(()=> Math.random()-0.5); }

function Timer(seconds, onTick, onEnd){
  let remain = seconds;
  const id = setInterval(()=> {
    remain--; onTick?.(remain);
    if (remain <= 0){ clearInterval(id); onEnd?.(); }
  }, 1000);
  onTick?.(remain);
  return { stop(){ clearInterval(id); } };
}

function startGame(){
  UI.clear();
  const container = document.createElement('div');
  const initialTarget = rand(1,10);
  container.innerHTML = `
    <div class="toolbar centered">
      <div class="target">ÈšintÄƒ: <strong id="duckTarget">${initialTarget}</strong></div>
      <div class="pill-row">
        <div class="pill" id="duckScore">âœ… Corecte: 0 â€¢ ğŸ¬ 0</div>
        <div class="pill" id="duckTime">â³ 45</div>
      </div>
    </div>
    <div class="game-area" id="pond"></div>
  `;
  UI.screen.appendChild(container);

  const pond = document.getElementById('pond');

  let correct = 0, candiesEarned = 0, currentTarget = initialTarget;
  const pads = [];
  let positions = [];
  const cols = 5, rows = 2, padW = 110, padH = 110;

  function computePositions(){
    const rect = pond.getBoundingClientRect();
    const gapX = (rect.width  - cols*padW) / (cols+1);
    const gapY = (rect.height - rows*padH) / (rows+1);
    const list = [];
    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        const x = Math.round(gapX + c*(padW+gapX) + padW/2);
        const y = Math.round(gapY + r*(padH+gapY) + padH/2);
        list.push({x, y});
      }
    }
    return list;
  }

  function placePads(){
    positions = computePositions();
    const numbers = Array.from({length:10}, (_,i)=> i+1);
    numbers.forEach((n, i)=>{
      const pos = positions[i];
      const pad = document.createElement('div');
      pad.className = 'lily-pad';
      pad.textContent = n;
      pad.dataset.number = n;
      pad.style.left = (pos.x - padW/2) + 'px';
      pad.style.top  = (pos.y - padH/2) + 'px';
      pad.addEventListener('click', ()=>{
        const chosen = Number(pad.dataset.number);
        if(chosen === currentTarget){
          correct++; candiesEarned++;
          App.addPoints(1); App.addCandies(1);
          newTarget();
        } else {
          alert("Ai pierdut!");
        }
        update();
      });
      pond.appendChild(pad);
      pads.push(pad);
    });
  }

  function newTarget(){
    let t;
    do { t = rand(1,10); } while(t===currentTarget);
    currentTarget = t;
    document.getElementById('duckTarget').textContent = t;
  }

  function update(){
    document.getElementById('duckScore').textContent = `âœ… Corecte: ${correct} â€¢ ğŸ¬ ${candiesEarned}`;
  }

  placePads();

  const tmr = Timer(45, (r)=> {
    const el = document.getElementById('duckTime');
    if (el) el.textContent = `â³ ${r}`;
  }, ()=> alert("Timpul a expirat!"));

  // curÄƒÈ›are la ieÈ™ire din paginÄƒ (de ex. schimbare joc)
  window.addEventListener('beforeunload', ()=> tmr.stop());
}

document.addEventListener('DOMContentLoaded', startGame);
  :root {
  --bg: #0f172a; --panel: #111827; --soft: #1f2937;
  --muted: #9ca3af; --text: #f9fafb; --primary: #22c55e;
  --accent: #60a5fa; --shadow: 0 10px 25px rgba(0,0,0,.35);
  --radius: 16px;
}

body {
  margin: 0;
  background: radial-gradient(1000px 600px at 50% -10%, #1e293b, var(--bg));
  color: var(--text);
  font-family: system-ui, sans-serif;
  min-height: 100vh;
}

header, footer { padding: 14px 20px; }
header .bar, footer .bar {
  max-width: 1100px; margin: 0 auto;
  display: flex; align-items: center; justify-content: space-between;
}
.brand { font-weight: 800; }
.brand span { color: var(--primary); }
.pill {
  background: rgba(255,255,255,.08);
  padding: 8px 12px;
  border-radius: 999px;
  box-shadow: var(--shadow);
}
.panel {
  background: rgba(255,255,255,.02);
  border: 1px solid rgba(255,255,255,.08);
  border-radius: var(--radius);
  padding: 18px;
  box-shadow: var(--shadow);
  margin: 20px auto;
  max-width: 1100px;
}

/* toolbar */
.toolbar.centered {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
.target { font-size: 28px; font-weight: 900; color: var(--accent); }
.target strong { font-size: 40px; color: var(--primary); }
.pill-row { display: flex; gap: 10px; }

/* aria joc */
.game-area {
  position: relative;
  background: linear-gradient(180deg, #0b3a6d, #062e57);
  border-radius: var(--radius);
  min-height: 480px;
  overflow: hidden;
}

/* nuferi + rata */
.lily-pad {
  position: absolute;
  width: 110px; height: 110px;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, #30a46c, #18794e);
  border: 3px solid #0e5b3a;
  color: #eafff5;
  font-weight: 900; font-size: 32px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  box-shadow: 0 8px 16px rgba(0,0,0,.35);
}

.duck {
  position: absolute;
  font-size: 52px;
  transform: translate(-50%, -70%);
  transition: left .25s ease, top .25s ease, transform .25s ease;
}

.splash {
  position: absolute;
  pointer-events: none;
  width: 12px; height: 12px;
  border-radius: 999px;
  background: rgba(255,255,255,.6);
  animation: ripple .6s ease-out forwards;
}
@keyframes ripple { to { opacity: 0; transform: scale(6); } }

acesta este un minijoc. as vrea sa aibe:
  nuferii sa fie asezati in forma de cerc, iar ratusca sa fie pozitionata in mijlocul cerucului
  o ratusca care sa sara pe alt nufar de fiecare daca cand se da un raspuns corect, iar ratusca sa fie afisata pe nufarul pe care sare 
  cand se da un raspuns gresit ratusca sa cada cu tot cu nufar in gol si sa apara pe mijlocul ecranului 
     ai pierdut
     sa iti spuna cate puncte si bomboane ai castigat
     sa fie un buton numit meniu care te duce la pagina de start
     sa fie un butun numit reincearca care iti regenereaza jocul si il joci din nou 
     